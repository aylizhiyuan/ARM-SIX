# 数据结构与算法的学习

1.  **数据结构的基本概念**  

数据：程序的操作对象，用于描述客观的事物
数据元素：组成数据的基本单位
数据项：一个数据元素由若干数据项组成
数据对象：性质相同的数据元素的集合（数组、链表）
数据结构：指数据对象中数据元素之间的关系

举例：

    //一种数据结构
    struct MyTeacher(){
        charname[32];
        chartitle[32];
        int age;
        char addr[128];
    }
    int main(){
        struct MyTeacher t1; //数据元素
        strcut MyTeacher tArray[30] //数据对象
        strcpy(t1.name,"name") // 数据项
    }

    
2.  **数据的逻辑结构**   

指的是元素之间的逻辑关系，即从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的，逻辑结构细分为四类：   

- 集合：数据元素间除了同属于一个集合外，无其他任何关系
- 线性结构：一个对一个，如线性表、栈、队列
- 树形结构：一个对多个，如树
- 图状结构：多个对多个，如图

3. **数据的物理结构**

指的是存储结构，是数据在计算机存储器内的表示

存储结构可分为4大类：
- 顺序：借助元素在存储器中的相对位置来表示数据元素间的逻辑关系
- 链式：借助指示元素存储地址的指针来表示数据元素之间的逻辑关系
- 索引
- 散列  

4. **数据的运算**

在数据的逻辑结构上定义的操作，它在数据的存储结构上实现。

最常用的数据运算有五种：
插入、删除、修改、查找、排序

5. **算法的概念**

算法是特定问题求解步骤的描述        
算法的特性： 
- 输入：算法具有0个或多个输入
- 输出：算法至少有1个或多个输出
- 有穷性：算法在有限的步骤之后自动结束而不会无限循环
- 确定性：算法中的每一步都有确定的含义，不会出现二义性
- 可行性：算法的每一步都是可行的

6. **算法效率的度量**

- 事后统计法：比较不同算法对同一组输入数据的运行处理时间
- 事前分析估算：依据统计的方法对算法的效率进行估算


7. **大O表示法**

算法的效率严重依赖于操作的数量，在判断时首先关注操作数量(可以理解为操作步骤)的最高次项，操作数量的估算可以作为时间复杂度的估算

    时间复杂度
    O(5) = O(1)
    O(2n+1) = O(2n) = O(n)
    O(n2+n+1) = O(n2)
    O(3n3+1) = O(3n3) = O(n3)
    注意:判断一个算法的效率的时候，往往只需要关注操作数量的最高次项，其他次要性和常数项可以忽略

    空间复杂度：算法的空间复杂度通过计算算法的存储空间实现  
    S(n) = O(f(n))
    其中，n为问题规模，f(n)为在问题规模为n的时候所占用的存储空间的函数
    大O表示法同样适用于算法的空间复杂度
    当算法执行时候所需要的空间是常数时候，空间复杂度为O(1)

> 多数情况下，算法执行时所用的时间更令人关注，如果有必要，可以通过增加空间复杂度来降低时间复杂度，同理，也可以通过增加时间复杂度来降低空间复杂度


8. **一对一的线性表**

- 线性表:所有的数据用一根线串起来，再存储到物理空间中

    - 顺序表:顺序存储,将数据一次存储在连续的物理空间中(空间一旦开辟无法改变大小)

    - 链表:链式存储:数据分散的存储在物理空间中，通过一根线保存他们之间的逻辑关系(后期可以开辟新的空间)

        - 单向链表:表中各节点都只包含一个指针且统一指向直接后继节点
        - 双向链表:各节点之间的逻辑关系是双向的
        - 循环链表:将单链表的两头连接，使其成为一个环状链表
        - 双向循环链表:将双链表的两头连接，构成双向循环链表

    - 栈:一种只能从表的一端存储数据且遵循"先进后出"原则的线性存储结构

    - 队列:一种从一端进，另一端出且遵循"先进先出"原则的线性存储结构

    - 字符串:是一种只用来存储字符类型的线性存储结构

    - 数组:数组可以看做是顺序表的基本表现形式，而n维的数组可以看做是对线性表的一种扩展，注意，数组只能放相同类型的数据

    - 广义表:也叫列表，可以同时存储原子(不可再分的数据和子表(另外一个广义表)两种形式的数据


9. **一对多的树**

- 树:将具有"一对多"关系的集合中的数据按照生活中的树的结构存储起来

    - 无序树:如果树中节点的子树从左到右看，谁在左边，谁在右边，没有规定，称为无序树
    - 有序树:如果树中节点的子树从左到右看，谁在左边，谁在右边，是有规定的，称为有序树
    - 二叉树:本身是有序树，树中包含的各个节点的度不超过2，即只能是0,1或者2
    - 满二叉树:如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树称为满二叉树
    - 完全二叉树:如果二叉树中除去最后一层节点为满二叉树，且最后一层的节点依次从左到右分布，则此二叉树称为完全二叉树
    - 哈夫曼树:当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”
    - 平衡二叉树:其实就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度差都不超过 1,则这棵二叉树就是平衡二叉树(AVL树)
    - 二叉查找树(二叉排序树)
        - 二叉排序树中，如果其根结点有左子树，那么左子树上所有结点的值都小于根结点的值
        - 二叉排序树中，如果其根结点有右子树，那么右子树上所有结点的值都大于根结点的值
        - 二叉排序树的左右子树也要求都是二叉排序树
    - 红黑树:本身是一颗二叉查找树，并且树中的每个节点增加一个用于存储颜色的标志域，树中没有一条路径比其他任何路径长出2倍，整棵树接近平衡状态
    - B-树
        - 树中每个节点之多有m棵子树
        - 若根节点不是叶子节点，则至少有两颗子树
        - 除根之外的所有非终端节点至少有棵子树
        - 所有的非终端节点中包含下列信息数据:(n,A0,k1,A1,k2,A2,....,kn,An);
    - B+树(区别)
        - 有n棵子树的节点包含了n个关键字
        - 所有的叶子节点中包含了全部的关键字的信息及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接
        - 所有的非终端节点(非叶子节点)可以看成是索引部分，节点中仅含有其子树(根节点)中的最大(或最小)关键字

10. **多对多的图**

- 图
    - 完全图:若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图。同时，满足此条件的有向图则称为有向完全图
    - 连通图:无向图中，如果任意两个顶点之间都能够连通，则称此无向图为连通图
    - 稀疏图/稠密图:这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为"稀疏图"；反之，则称此图为"稠密图"。




